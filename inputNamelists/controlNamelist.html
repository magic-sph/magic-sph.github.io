<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Control namelist &#8212; Magic 6.2 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/magic.css?v=a97dc138" />
    
    <script src="../_static/documentation_options.js?v=ef7fcc1c"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Magic 6.2 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Physical parameters namelist" href="physNamelist.html" />
    <link rel="prev" title="Grid namelist" href="gridNamelist.html" />
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300,400,700'
          rel='stylesheet' type='text/css' />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1/jquery.js"></script>
    <script src="galleria/galleria-1.4.2.min.js"></script>
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
  </style>
  <script type="text/javascript">
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

  </head><body>
<div class="pageheader">
  <ul>
    <li><a href="../index.html">Home</a></li>
    <li><a href="../install.html">Get it/Run it</a></li>
    <li><a href="../contribute.html">Contribute!</a></li>
    <li><a href="../numerics.html">Numerical methods</a></li>
    <li><a href="../contents.html">Contents</a></li>
  </ul>
  <div>
    <a href="../index.html">
      <img src="../_static/logo.png" alt="magic" height="120px" width="192px"/>
    </a>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../f-modindex.html" title="Fortran Module Index"
             >fortran modules</a> |</li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="physNamelist.html" title="Physical parameters namelist"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="gridNamelist.html" title="Grid namelist"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../contents.html">Magic 6.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="namelists.html" accesskey="U">Input parameters</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Control namelist</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="control-namelist">
<span id="seccontrolnml"></span><h1>Control namelist<a class="headerlink" href="#control-namelist" title="Link to this heading">¶</a></h1>
<p>This namelist defines the numerical parameters of the problem plus the
variables that control and organize the run.</p>
<ul id="varmode">
<li><p><strong>mode</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/physical_parameters/mode" title="f/physical_parameters/mode"><code class="xref f f-var docutils literal notranslate"><span class="pre">mode=0</span></code></a>) is an integer which controls the type of calculation performed.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>mode=0</p></td>
<td><p>Self-consistent dynamo</p></td>
</tr>
<tr class="row-even"><td><p>mode=1</p></td>
<td><p>Convection</p></td>
</tr>
<tr class="row-odd"><td><p>mode=2</p></td>
<td><p>Kinematic dynamo</p></td>
</tr>
<tr class="row-even"><td><p>mode=3</p></td>
<td><p>Magnetic decay modes</p></td>
</tr>
<tr class="row-odd"><td><p>mode=4</p></td>
<td><p>Magneto convection</p></td>
</tr>
<tr class="row-even"><td><p>mode=5</p></td>
<td><p>Linear onset of convection</p></td>
</tr>
<tr class="row-odd"><td><p>mode=6</p></td>
<td><p>Self-consistent dynamo, but with no Lorentz force</p></td>
</tr>
<tr class="row-even"><td><p>mode=7</p></td>
<td><p>Super-rotating inner core or mantle, no convection and
no magnetic field</p></td>
</tr>
<tr class="row-odd"><td><p>mode=8</p></td>
<td><p>Super-rotating inner core or mantle, no convection</p></td>
</tr>
<tr class="row-even"><td><p>mode=9</p></td>
<td><p>Super-rotating inner core or mantle, no convection
and no Lorentz force</p></td>
</tr>
<tr class="row-odd"><td><p>mode=10</p></td>
<td><p>Super-rotating inner core or mantle, no convection,
no magnetic field, no Lorentz force and no advection</p></td>
</tr>
</tbody>
</table>
</li>
</ul>
<ul class="simple" id="vartag">
<li><p><strong>tag</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/output_data/tag" title="f/output_data/tag"><code class="xref f f-var docutils literal notranslate"><span class="pre">tag=&quot;default&quot;</span></code></a>) is a character string, used as an extension for all output files.</p></li>
<li><p><strong>n_time_steps</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/num_param/n_time_steps" title="f/num_param/n_time_steps"><code class="xref f f-var docutils literal notranslate"><span class="pre">n_time_steps=100</span></code></a>) is an integer, the number of time steps to be performed.</p></li>
<li><p><strong>tEND</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/num_param/tend" title="f/num_param/tend"><code class="xref f f-var docutils literal notranslate"><span class="pre">tEND=0.0</span></code></a>) is a real, which can be used to force the code to stop when :math:<code class="docutils literal notranslate"><span class="pre">t=tEND</span></code>. This is only used when <code class="docutils literal notranslate"><span class="pre">t/=tEND</span></code>.</p></li>
<li><p><strong>alpha</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/num_param/alpha" title="f/num_param/alpha"><code class="xref f f-var docutils literal notranslate"><span class="pre">alpha=0.5</span></code></a>) is a real. This is the weight used for current time step in implicit time step.</p></li>
</ul>
<section id="default-scales">
<h2>Default scales<a class="headerlink" href="#default-scales" title="Link to this heading">¶</a></h2>
<ul>
<li><p><strong>n_tScale</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/num_param/n_tscale" title="f/num_param/n_tscale"><code class="xref f f-var docutils literal notranslate"><span class="pre">n_tScale=0</span></code></a>) is an integer, which determines the time scaling</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>n_tScale=0</p></td>
<td><p>Use viscous time scale.</p></td>
<td><p><span class="math notranslate nohighlight">\(d^2/\nu\)</span></p></td>
</tr>
<tr class="row-even"><td><p>n_tScale=1</p></td>
<td><p>Use magnetic time scale.</p></td>
<td><p><span class="math notranslate nohighlight">\(d^2/\eta\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>n_tScale=2</p></td>
<td><p>Use thermal time scale.</p></td>
<td><p><span class="math notranslate nohighlight">\(d^2/\kappa\)</span></p></td>
</tr>
<tr class="row-even"><td><p>n_tScale=3</p></td>
<td><p>Use rotational time scale.</p></td>
<td><p><span class="math notranslate nohighlight">\(\Omega^{-1}\)</span></p></td>
</tr>
</tbody>
</table>
</li>
<li><p><strong>n_lScale</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/num_param/n_lscale" title="f/num_param/n_lscale"><code class="xref f f-var docutils literal notranslate"><span class="pre">n_lScale=0</span></code></a>) is an integer which determines the reference length scale.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>n_lScale=0</p></td>
<td><p>Use outer core.</p></td>
</tr>
<tr class="row-even"><td><p>n_lScale=1</p></td>
<td><p>Use total core.</p></td>
</tr>
</tbody>
</table>
</li>
<li><p><strong>enscale</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/num_param/enscale" title="f/num_param/enscale"><code class="xref f f-var docutils literal notranslate"><span class="pre">enscale=1.0</span></code></a>) is a real. This is the scaling for energies.</p></li>
</ul>
</section>
<section id="update-control">
<h2>Update control<a class="headerlink" href="#update-control" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p><strong>l_update_v</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/logic/l_update_v" title="f/logic/l_update_v"><code class="xref f f-var docutils literal notranslate"><span class="pre">l_update_v=.true.</span></code></a>) is a logical that specifies whether the velocity field should be time-stepped or not.</p></li>
<li><p><strong>l_update_b</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/logic/l_update_b" title="f/logic/l_update_b"><code class="xref f f-var docutils literal notranslate"><span class="pre">l_update_b=.true.</span></code></a>) is a logical that specifies whether the magnetic field should be time-stepped or not.</p></li>
<li><p><strong>l_update_s</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/logic/l_update_s" title="f/logic/l_update_s"><code class="xref f f-var docutils literal notranslate"><span class="pre">l_update_s=.true.</span></code></a>) is a logical that specifies whether the entropy/temperature should be time-stepped or not.</p></li>
<li><p><strong>l_update_xi</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/logic/l_update_xi" title="f/logic/l_update_xi"><code class="xref f f-var docutils literal notranslate"><span class="pre">l_update_xi=.true.</span></code></a>) is a logical that specifies whether the chemical composition should be time-stepped or not.</p></li>
<li><p><strong>l_update_phi</strong> (default <code class="xref f f-var docutils literal notranslate"><span class="pre">l_update_phi=.true.</span></code>) is a logical that specifies whether the phase field should be time-stepped or not.</p></li>
</ul>
</section>
<section id="time-step-control">
<h2>Time step control<a class="headerlink" href="#time-step-control" title="Link to this heading">¶</a></h2>
<p>A modified Courant criterion including a modified Alfven-velocity is used to
account for the magnetic field. The relative and absolute importance of flow
and Alfven-velocity can be controled by <strong>courfac</strong> and <strong>alffac</strong> respectively.
The parameter <strong>l_cour_alf_damp</strong> allows to choose whether the actual Alven speed
is used to estimate the Courant condition or if damping is included. Practically,
the timestep size is controlled as follows</p>
<div class="math notranslate nohighlight">
\[\delta t &lt; \min_{V}\left( c_I\,E,\, \dfrac{\delta r}{|u_r|},\, \dfrac{\delta h}{u_h} \right)\]</div>
<p>where <span class="math notranslate nohighlight">\(u_h=(u_\theta^2+u_\phi^2)^{1/2}\)</span>, <span class="math notranslate nohighlight">\(\delta h = \dfrac{r}{\sqrt{\ell(\ell+1)}}\)</span>, and <span class="math notranslate nohighlight">\(\delta r\)</span> is the radial grid interval. The first term in the left hand side accounts for the explicit treatment of the Coriolis term.</p>
<div class="math notranslate nohighlight">
\[{|u_r|}=c_F{|u_{F,r}|}+c_A\dfrac{u_{A,r}^2}{\left[u_{A,r}^2+\left(\frac{1+Pm^{-1}}{2\delta r}\right)^2\right]^{1/2}}\,,\]</div>
<p>where <span class="math notranslate nohighlight">\(u_{F,r}\)</span> is the radial component of the fluid velocity and <span class="math notranslate nohighlight">\(u_{A,r}=Br/\sqrt{E\,Pm}\)</span> is the radial Alven velocity. The denominator of the rightmost term accounts for the damping of the Alven waves.</p>
<ul>
<li><p><strong>dtMax</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/num_param/dtmax" title="f/num_param/dtmax"><code class="xref f f-var docutils literal notranslate"><span class="pre">dtMax=1e-4</span></code></a>) is a  real. This is the maximum allowed time step <span class="math notranslate nohighlight">\(\delta t\)</span>. If <span class="math notranslate nohighlight">\(\delta t &gt; \hbox{dtmax}\)</span>, the time step is decreased to at least dtMax (See routine <cite>dt_courant</cite>). Run is stopped if <span class="math notranslate nohighlight">\(\delta t &lt; \hbox{dtmin}\)</span> and <span class="math notranslate nohighlight">\(\hbox{dtmin}=10^{-6}\,\hbox{dtmax}\)</span>.</p></li>
<li><p><strong>courfac</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/num_param/courfac" title="f/num_param/courfac"><code class="xref f f-var docutils literal notranslate"><span class="pre">courfac=2.5</span></code></a>) is a real used to scale velocity in Courant criteria. This parameter corresponds to <span class="math notranslate nohighlight">\(c_F\)</span> in the above equation.</p></li>
<li><p><strong>alffac</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/num_param/alffac" title="f/num_param/alffac"><code class="xref f f-var docutils literal notranslate"><span class="pre">alffac=1.0</span></code></a>) is a  real, used to scale Alfven-velocity in Courant criteria. This parameter corresponds to <span class="math notranslate nohighlight">\(c_A\)</span> in the above equation.</p></li>
<li><p><strong>intfac</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/num_param/intfac" title="f/num_param/intfac"><code class="xref f f-var docutils literal notranslate"><span class="pre">intfac=0.15</span></code></a>) is a  real, used to scale Coriolis factor in Courant criteria. This parameter corresponds to <span class="math notranslate nohighlight">\(c_I\)</span> in the above equation.</p></li>
<li><p><strong>l_cour_alf_damp</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/logic/l_cour_alf_damp" title="f/logic/l_cour_alf_damp"><code class="xref f f-var docutils literal notranslate"><span class="pre">l_cour_alf_damp=.true.</span></code></a>) is a logical. This is used to decide whether the damping of the Alven waves is taken into account when estimating the Courant condition (see Christensen et al., GJI, 1999). At low Ekman numbers, this criterion might actually lead to spurious oscillations/instabilities of the code. When turn to False, <span class="math notranslate nohighlight">\({|u_r|}=c_F{|u_{F,r}|}+c_A{|u_{A,r}|}\)</span>.</p></li>
<li><p><strong>time_scheme</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/num_param/time_scheme" title="f/num_param/time_scheme"><code class="xref f f-var docutils literal notranslate"><span class="pre">time_scheme='CNAB2'</span></code></a>) is a character string. This is used to choose the time step integrator used in the code among the following implicit-explicit time schemes:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>time_scheme=’CNAB2’</p></td>
<td><p>Crank-Nicolson and 2nd order Adams-Bashforth scheme</p></td>
</tr>
<tr class="row-even"><td><p>time_scheme=’CNLF’</p></td>
<td><p>Crank-Nicolson and Leap-Frog scheme</p></td>
</tr>
<tr class="row-odd"><td><p>time_scheme=’MODCNAB’</p></td>
<td><p>Modified CN/AB2</p></td>
</tr>
<tr class="row-even"><td><p>time_scheme=’SBDF2’</p></td>
<td><p>Semi-implicit backward difference scheme of 2nd order</p></td>
</tr>
<tr class="row-odd"><td><p>time_scheme=’SBDF3’</p></td>
<td><p>Semi-implicit backward difference scheme of 3rd order</p></td>
</tr>
<tr class="row-even"><td><p>time_scheme=’SBDF4’</p></td>
<td><p>Semi-implicit backward difference scheme of 4th order</p></td>
</tr>
<tr class="row-odd"><td><p>time_scheme=’ARS222’</p></td>
<td><p>Semi-implicit S-DIRK of 2nd order</p></td>
</tr>
<tr class="row-even"><td><p>time_scheme=’ARS232’</p></td>
<td><p>Semi-implicit S-DIRK of 2nd order</p></td>
</tr>
<tr class="row-odd"><td><p>time_scheme=’CK232’</p></td>
<td><p>Semi-implicit S-DIRK of 2nd order</p></td>
</tr>
<tr class="row-even"><td><p>time_scheme=’LZ232’</p></td>
<td><p>Semi-implicit S-DIRK of 2nd order</p></td>
</tr>
<tr class="row-odd"><td><p>time_scheme=’PC2’</p></td>
<td><p>Semi-implicit S-DIRK of 2nd order</p></td>
</tr>
<tr class="row-even"><td><p>time_scheme=’CB3’</p></td>
<td><p>Semi-implicit S-DIRK of 3rd order</p></td>
</tr>
<tr class="row-odd"><td><p>time_scheme=’ARS343’</p></td>
<td><p>Semi-implicit S-DIRK of 3rd order</p></td>
</tr>
<tr class="row-even"><td><p>time_scheme=’MARS343’</p></td>
<td><p>Semi-implicit S-DIRK of 3rd order</p></td>
</tr>
<tr class="row-odd"><td><p>time_scheme=’ARS443’</p></td>
<td><p>Semi-implicit S-DIRK of 3rd order</p></td>
</tr>
<tr class="row-even"><td><p>time_scheme=’BPR353’</p></td>
<td><p>Semi-implicit S-DIRK of 3rd order</p></td>
</tr>
<tr class="row-odd"><td><p>time_scheme=’BHR553’</p></td>
<td><p>Semi-implicit S-DIRK of 3rd order</p></td>
</tr>
<tr class="row-even"><td><p>time_scheme=’DBM453’</p></td>
<td><p>Semi-implicit S-DIRK of 3rd order</p></td>
</tr>
<tr class="row-odd"><td><p>time_scheme=’LZ453’</p></td>
<td><p>Semi-implicit S-DIRK of 3rd order</p></td>
</tr>
<tr class="row-even"><td><p>time_scheme=’KC343’</p></td>
<td><p>Semi-implicit S-DIRK of 3rd order</p></td>
</tr>
<tr class="row-odd"><td><p>time_scheme=’KC564’</p></td>
<td><p>Semi-implicit S-DIRK of 4th order</p></td>
</tr>
<tr class="row-even"><td><p>time_scheme=’KC674’</p></td>
<td><p>Semi-implicit S-DIRK of 4th order</p></td>
</tr>
<tr class="row-odd"><td><p>time_scheme=’KC785’</p></td>
<td><p>Semi-implicit S-DIRK of 5th order</p></td>
</tr>
</tbody>
</table>
</li>
</ul>
</section>
<section id="run-time">
<h2>Run time<a class="headerlink" href="#run-time" title="Link to this heading">¶</a></h2>
<p>The total desired runtime (in human units and not in CPU units) can be specified with the three variables <strong>runHours</strong>, <strong>runMinutes</strong> and <strong>runSeconds</strong>.</p>
<ul class="simple">
<li><p><strong>runHours</strong> (default <a class="reference internal" href="../apiFortran/initModules.html#f/namelists/runhours" title="f/namelists/runhours"><code class="xref f f-var docutils literal notranslate"><span class="pre">runHours=0</span></code></a>) is an integer that controls the number of run hours.</p></li>
<li><p><strong>runMinutes</strong> (default <a class="reference internal" href="../apiFortran/initModules.html#f/namelists/runminutes" title="f/namelists/runminutes"><code class="xref f f-var docutils literal notranslate"><span class="pre">runMinutes=0</span></code></a>) is an integer that controls the .</p></li>
<li><p><strong>runSeconds</strong> (default <a class="reference internal" href="../apiFortran/initModules.html#f/namelists/runseconds" title="f/namelists/runseconds"><code class="xref f f-var docutils literal notranslate"><span class="pre">runSeconds=0</span></code></a>) is an integer that controls the number of run hours.</p></li>
</ul>
<p>Here is an example for a run of 23h30:</p>
<div class="highlight-fortran notranslate"><div class="highlight"><pre><span></span><span class="n">runHours</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mi">23</span><span class="p">,</span>
<span class="n">runMinutes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">,</span>
</pre></div>
</div>
</section>
<section id="hyperdiffusivity">
<h2>Hyperdiffusivity<a class="headerlink" href="#hyperdiffusivity" title="Link to this heading">¶</a></h2>
<p>Hyperdiffusion can be applied by multiplying the diffusion operators by a factor of the form</p>
<div class="math notranslate nohighlight">
\[d(\ell)=1+D\left[\frac{\ell+1-\ell_{hd}}{\ell_{max}+1-\ell_{hd}} \right]^{\beta}\]</div>
<p>for the spherical harmonic degrees <span class="math notranslate nohighlight">\(\ell \geq \ell_{hd}\)</span>.</p>
<ul class="simple">
<li><p><strong>difnu</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/num_param/difnu" title="f/num_param/difnu"><code class="xref f f-var docutils literal notranslate"><span class="pre">difnu=0.0</span></code></a>) is a real. This is the amplitude <span class="math notranslate nohighlight">\(D\)</span> of the viscous hyperdiffusion.</p></li>
<li><p><strong>difkappa</strong> (default <code class="xref f f-var docutils literal notranslate"><span class="pre">difkappa=0.0</span></code>) is a real. This is the amplitude <span class="math notranslate nohighlight">\(D\)</span> of the thermal hyperdiffusion.</p></li>
<li><p><strong>difchem</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/num_param/difchem" title="f/num_param/difchem"><code class="xref f f-var docutils literal notranslate"><span class="pre">difchem=0.0</span></code></a>) is a real. This is the amplitude <span class="math notranslate nohighlight">\(D\)</span> of the hyperdiffusion applied to chemical composition.</p></li>
<li><p><strong>difeta</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/num_param/difeta" title="f/num_param/difeta"><code class="xref f f-var docutils literal notranslate"><span class="pre">difeta=0.0</span></code></a>) is a real. This is the amplitude <span class="math notranslate nohighlight">\(D\)</span> of the magnetic hyperdiffusion.</p></li>
<li><p><strong>ldif</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/num_param/ldif" title="f/num_param/ldif"><code class="xref f f-var docutils literal notranslate"><span class="pre">ldif=1</span></code></a>) is an integer. This is the degree <span class="math notranslate nohighlight">\(\ell_{hd}\)</span> where hyperdiffusion starts to act.</p></li>
<li><p><strong>ldifexp</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/num_param/ldifexp" title="f/num_param/ldifexp"><code class="xref f f-var docutils literal notranslate"><span class="pre">ldifexp=-1</span></code></a>) is an integer. This is the exponent <span class="math notranslate nohighlight">\(\beta\)</span> of hyperdiffusion.</p></li>
</ul>
</section>
<section id="angular-momentum-correction">
<h2>Angular momentum correction<a class="headerlink" href="#angular-momentum-correction" title="Link to this heading">¶</a></h2>
<p>In case of the use of stress-free boundary conditions at both boundaries, it is safer to ensure
that the angular momentum is correctly conserved. This can be enforced through the following
input variables:</p>
<ul class="simple">
<li><p><strong>l_correct_AMe</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/logic/l_correct_ame" title="f/logic/l_correct_ame"><code class="xref f f-var docutils literal notranslate"><span class="pre">l_correct_AMe=.false.</span></code></a>) is a logical. This is used to correct the equatorial angular momentum.</p></li>
<li><p><strong>l_correct_AMz</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/logic/l_correct_amz" title="f/logic/l_correct_amz"><code class="xref f f-var docutils literal notranslate"><span class="pre">l_correct_AMz=.false.</span></code></a>) is a logical. This is used to correct the axial angular momentum.</p></li>
</ul>
</section>
<section id="radial-scheme-and-mapping-of-the-gauss-lobatto-grid">
<span id="varl-newmap"></span><h2>Radial scheme and mapping of the Gauss-Lobatto grid<a class="headerlink" href="#radial-scheme-and-mapping-of-the-gauss-lobatto-grid" title="Link to this heading">¶</a></h2>
<p>In MagIC, one can either use finite differences or Chebyshev polynomials for the radial integration scheme. This choice is controlled by the following input parameter:</p>
<ul>
<li><p><strong>radial_scheme</strong> (default <a class="reference internal" href="../apiFortran/legFourierChebAlgebra.html#f/radial_scheme" title="f/radial_scheme: This is an abstract type that defines the radial scheme used in MagIC"><code class="xref f f-var docutils literal notranslate"><span class="pre">radial_scheme='CHEB'</span></code></a>) is a character string.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>radial_scheme=’CHEB’</p></td>
<td><p>Use Chebyshev polynomials</p></td>
</tr>
<tr class="row-even"><td><p>radial_scheme=’FD’</p></td>
<td><p>Use finite differences</p></td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>When Chebyshev polynomials are used, it is also possible to use a non-linear
mapping function to concentrate/diperse grid points around a point inside the
domain.</p>
<ul>
<li><p><strong>l_newmap</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/logic/l_newmap" title="f/logic/l_newmap"><code class="xref f f-var docutils literal notranslate"><span class="pre">l_newmap=.false.</span></code></a>) is a logical. A radial mapping can be applied to the Chebyshev grid when <code class="docutils literal notranslate"><span class="pre">l_newmap</span></code> is set to <code class="docutils literal notranslate"><span class="pre">.true.</span></code>. The radial profile of the mapping function is then stored during the initialisation of the code in the file <a class="reference internal" href="../outputFiles/outTransportProp.html#secmappingfile"><span class="std std-ref">rNM.TAG</span></a>.</p></li>
<li><p><strong>map_function</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/num_param/map_function" title="f/num_param/map_function"><code class="xref f f-var docutils literal notranslate"><span class="pre">map_function='arcsin'</span></code></a>) is a character string. This allows to select which mapping function is used:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>map_function=’TAN’</p></td>
<td><p>Use a tangent mapping  (see <a class="reference external" href="https://doi.org/10.1016/0021-9991(92)90012-N">Bayliss and Turkel 1992</a>)</p></td>
</tr>
<tr class="row-even"><td><p>map_function=’ARCSIN’</p></td>
<td><p>Use an arcsin mapping  (see <a class="reference external" href="https://doi.org/10.1006/jcph.1993.1044">Kosloff and Tal-Ezer 1993</a>)</p></td>
</tr>
<tr class="row-odd"><td><p>map_function=’TT’</p></td>
<td><p>Use the mapping by <a class="reference external" href="https://doi.org/10.1137/050641296">Tee and Trefethen 2006</a></p></td>
</tr>
<tr class="row-even"><td><p>map_function=’JAFARI’</p></td>
<td><p>Use the mapping by <a class="reference external" href="https://doi.org/10.1007/s11075-014-9883-3">Jafari-Varzaneh and Hosseini 2014</a></p></td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>If the tangent mapping is used, the function that re-distributes the collocation
points is expressed by</p>
<div class="math notranslate nohighlight">
\[r=\frac{1}{2}\left(\alpha_2+\frac{\textrm{tan}\left[\lambda(x_{cheb}-x_0)\right]}{\alpha_1}\right) + \frac{r_i+r_o}{2} \textrm{ ,}\]</div>
<p>where the Gauss-Lobatto collocation points are</p>
<div class="math notranslate nohighlight">
\[x_{cheb}=\textrm{cos}\left( \frac{\pi(k-1)}{N_r} \right) \textrm{ , }\;\; k=1,2,...,n_r \textrm{ , }\; n_r=n\_r\_max\]</div>
<p>and <span class="math notranslate nohighlight">\(r\!\in\![r_i,r_o]\)</span>, <span class="math notranslate nohighlight">\(x_{cheb}\!\in\![-1.0,1.0]\)</span>. The parameters to calculate <span class="math notranslate nohighlight">\(r\)</span> are</p>
<div class="math notranslate nohighlight">
\[\begin{split}\lambda&amp;=\frac{\textrm{tan}^{-1}\left(\alpha_1(1-\alpha_2)\right)}{1-x_0} \\
x_0&amp;=\frac{K-1}{K+1} \\
K&amp;=\frac{\textrm{tan}^{-1}\left(\alpha_1(1+\alpha_2)\right)}{\textrm{tan}^{-1}\left(\alpha_1(1-\alpha_2)\right)} \textrm{ .}\end{split}\]</div>
<p>The coefficient <span class="math notranslate nohighlight">\(\alpha_1\)</span> determines the degree of concentration/dispersion of the grid points around <span class="math notranslate nohighlight">\(x_{cheb}\!=\!\alpha_2\)</span>. If <span class="math notranslate nohighlight">\(\alpha_1\)</span> is too high, the <span class="math notranslate nohighlight">\(r\)</span> function becomes nearly discontinuous. To avoid numerical problems, <span class="math notranslate nohighlight">\(\alpha_1\)</span> should remain close to unity.</p>
<p>If the arcsin mapping is used, the function that re-distributes the collocation points
is given by</p>
<div class="math notranslate nohighlight">
\[r=\frac{1}{2}\left[ \frac{\textrm{arcin}\left(\alpha_1 x_{cheb}\right)}{\textrm{arcsin} \alpha_1} \right]+\frac{r_i+r_o}{2} \textrm{ ,}\]</div>
<p>In the Kosloff and Tal-Ezer mapping, <span class="math notranslate nohighlight">\(\alpha_1\)</span> transforms the Gauss-Lobatto
grid into a more regularly-spaced grid. When <span class="math notranslate nohighlight">\(\alpha_1 \rightarrow 0\)</span> one
recovers the Gauss-Lobatto grid, while <span class="math notranslate nohighlight">\(\alpha_1 \rightarrow 1\)</span> yields a
regular grid.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The Kosloff-Tal-Ezer mapping becomes singular when <span class="math notranslate nohighlight">\(\alpha_1=1\)</span>.
Acceptable values are <span class="math notranslate nohighlight">\(0&lt;\alpha_1&lt;1\)</span>. Note that the error increases
as <span class="math notranslate nohighlight">\(\epsilon=\left(\frac{1-\sqrt{1-\alpha_1^2}}{\alpha_1}\right)^{N_r}\)</span>.</p>
</div>
<p>If the Tee and Trefethen sinh mapping is employed, the grid points are redistributed in the following manner</p>
<div class="math notranslate nohighlight">
\[r=\frac{1}{2}\left(\alpha_2+\frac{\textrm{sinh}\left[A(x_{cheb}-1)+B\right]}{\alpha_1}\right) + \frac{r_i+r_o}{2} \textrm{ ,}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[A=\frac{1}{2}\left[\textrm{sinh}(\alpha_1(1-\alpha_2))+\textrm{sinh}(\alpha_1(1+\alpha_2)) \right], \quad B = \textrm{sinh}(\alpha_1(1-\alpha_2))\]</div>
<p>With this mapping, <span class="math notranslate nohighlight">\(\alpha_1\)</span> is directly related to the stiffness of the transition.</p>
<p>If the Jafari-Varzaneh and Hosseini mapping is employed, similarly to the tangent mapping, <span class="math notranslate nohighlight">\(\alpha_1\)</span> determines the degree of concentration of the grid points around <span class="math notranslate nohighlight">\(x_{cheb}\!=\!\alpha_2\)</span>. This is expected to do a better job than the tangent mapping, both in terms of matrix conditioning and in terms of reducing the Gibbs phenomenon around a steep change (Allen-Cahn type of equations involved in the phase field model comes to mind).</p>
<ul class="simple">
<li><p><strong>alph1</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/num_param/alph1" title="f/num_param/alph1"><code class="xref f f-var docutils literal notranslate"><span class="pre">alph1=0.8</span></code></a>) is a real. This is a control parameter of the mapping function.</p></li>
<li><p><strong>alph2</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/num_param/alph2" title="f/num_param/alph2"><code class="xref f f-var docutils literal notranslate"><span class="pre">alph2=0.0</span></code></a>) is a real. This is a control parameter of the mapping function. The default value of <span class="math notranslate nohighlight">\(0\)</span> corresponds to the center of the grid.</p></li>
</ul>
</section>
<section id="miscellaneous">
<h2>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Link to this heading">¶</a></h2>
<ul>
<li><p><strong>l_non_rot</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/logic/l_non_rot" title="f/logic/l_non_rot"><code class="xref f f-var docutils literal notranslate"><span class="pre">l_non_rot=.false.</span></code></a>) is a logical. Use it when you want to do non-rotating numerical simulations.</p></li>
<li><p><strong>anelastic_flavour</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/num_param/anelastic_flavour" title="f/num_param/anelastic_flavour"><code class="xref f f-var docutils literal notranslate"><span class="pre">anelastic_flavour=&quot;None&quot;</span></code></a>) is a character string. This allows to change the thermal diffusion operator used within the anelastic approximation. Possible values are:</p>
<blockquote>
<div><table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>anelastic_flavour=’LBR’</p></td>
<td><p>Entropy diffusion</p></td>
</tr>
<tr class="row-even"><td><p>anelastic_flavour=’ENT’</p></td>
<td><p>Entropy diffusion</p></td>
</tr>
<tr class="row-odd"><td><p>anelastic_flavour=’ALA’</p></td>
<td><p>Anelastic liquid approximation</p></td>
</tr>
<tr class="row-even"><td><p>anelastic_flavour=’TDIFF’</p></td>
<td><p>Temperature diffusion</p></td>
</tr>
<tr class="row-odd"><td><p>anelastic_flavour=’TEMP’</p></td>
<td><p>Temperature diffusion</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
<li><p><strong>polo_flow_eq</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/num_param/polo_flow_eq" title="f/num_param/polo_flow_eq"><code class="xref f f-var docutils literal notranslate"><span class="pre">polo_flow_eq=&quot;WP&quot;</span></code></a>) is a character string. This allows to change how the equation for the poloidal flow potential is constructed. One can either use the radial component of the Navier-Stokes equation and hence keep a coupled system that involve the poloidal potential <span class="math notranslate nohighlight">\(W\)</span> and the pressure <span class="math notranslate nohighlight">\(p\)</span>, or take the radial component of the double-curl of the Navier-Stokes equation to suppress pressure.</p>
<blockquote>
<div><table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>polo_flow_eq=’WP’</p></td>
<td><p>Use the pressure formulation</p></td>
</tr>
<tr class="row-even"><td><p>polo_flow_eq=’DC’</p></td>
<td><p>Use the double-curl formulation</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
<li><p><strong>mpi_transp</strong> (default <code class="xref f f-var docutils literal notranslate"><span class="pre">mpi_transp=&quot;auto&quot;</span></code>) is a character string. It allows to change the way the global MPI transposes are handled by the code. By default, the code tries to determine by itself the fastest method. One can nevertheless force the code to use local communicators (such as Isend/Irecv/waitall), make use of the native alltoallv MPI variant or choose the alltoallw variant instead.</p>
<blockquote>
<div><table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>mpi_transp=’auto’</p></td>
<td><p>Automatic determination of the fastest transpose</p></td>
</tr>
<tr class="row-even"><td><p>mpi_transp=’p2p’</p></td>
<td><p>Use Isend/Irecv/Waitall communicators</p></td>
</tr>
<tr class="row-odd"><td><p>mpi_transp=’a2av’</p></td>
<td><p>Use alltoallv communicators</p></td>
</tr>
<tr class="row-even"><td><p>mpi_transp=’a2aw’</p></td>
<td><p>Use alltoallw communicators</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
<li><p><strong>mpi_packing</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/num_param/mpi_packing" title="f/num_param/mpi_packing"><code class="xref f f-var docutils literal notranslate"><span class="pre">mpi_packing=&quot;packed&quot;</span></code></a>) is a character string. It allows to change the size of the global MPI transposes. One can choose between some packing of the fields into buffers (default) or a sequence of single field transposes. There is a possible automatic detection but testing unfortunately reveals frequent false detection.</p>
<blockquote>
<div><table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>mpi_packing=’auto’</p></td>
<td><p>Automatic determination of the fastest transpose</p></td>
</tr>
<tr class="row-even"><td><p>mpi_packing=’packed’</p></td>
<td><p>Pack some fields into buffers</p></td>
</tr>
<tr class="row-odd"><td><p>mpi_packing=’single’</p></td>
<td><p>Transpose each field individually</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
<li><p><strong>l_adv_curl</strong> (default <a class="reference internal" href="../apiFortran/baseModules.html#f/logic/l_adv_curl" title="f/logic/l_adv_curl"><code class="xref f f-var docutils literal notranslate"><span class="pre">l_adv_curl=.true.</span></code></a>) is a logical. When set to True, the advection term is treated as <span class="math notranslate nohighlight">\(\vec{u}\times\vec{\omega}\)</span> instead of <span class="math notranslate nohighlight">\(\vec{u}\vec{\nabla}\vec{u}\)</span>. The practical consequence of that is to reduce the number of spectral/spatial Spherical Harmonic Transforms and hence to speed-up the code. Because of the treatment of the viscous heating term in the anelastic approximation, this is only an option when considering Boussinesq models.</p></li>
</ul>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Control namelist</a><ul>
<li><a class="reference internal" href="#default-scales">Default scales</a></li>
<li><a class="reference internal" href="#update-control">Update control</a></li>
<li><a class="reference internal" href="#time-step-control">Time step control</a></li>
<li><a class="reference internal" href="#run-time">Run time</a></li>
<li><a class="reference internal" href="#hyperdiffusivity">Hyperdiffusivity</a></li>
<li><a class="reference internal" href="#angular-momentum-correction">Angular momentum correction</a></li>
<li><a class="reference internal" href="#radial-scheme-and-mapping-of-the-gauss-lobatto-grid">Radial scheme and mapping of the Gauss-Lobatto grid</a></li>
<li><a class="reference internal" href="#miscellaneous">Miscellaneous</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="gridNamelist.html"
                          title="previous chapter">Grid namelist</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="physNamelist.html"
                          title="next chapter">Physical parameters namelist</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/inputNamelists/controlNamelist.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../f-modindex.html" title="Fortran Module Index"
             >fortran modules</a> |</li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="physNamelist.html" title="Physical parameters namelist"
             >next</a> |</li>
        <li class="right" >
          <a href="gridNamelist.html" title="Grid namelist"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../contents.html">Magic 6.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="namelists.html" >Input parameters</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Control namelist</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2023, Thomas Gastine, Johannes Wicht, Ankit Barik, Lùcia Duarte.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>